# 进程调度

## 概念

+ 响应时间： 完成一件事
+ 周转时间： 计算做一件事

![image-20210421003739783](https://cdn.jsdelivr.net/gh/yanzhenxing123/blogImg@master/typora202104/21/003740-963440.png)



## 进程调度算法

### FCFS

`first come first serve`

先来先服务



| 进程 | 到达时间 | 服务时间 |
| ---- | -------- | -------- |
| A    | 0        | 3        |
| B    | 2        | 6        |
| C    | 4        | 4        |
| D    | 6        | 5        |
| E    | 8        | 2        |

简单模拟时间轴表示其过程：



|      | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   | 16   | 17   | 18   | 19   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| A    | A    | A    | A    |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| B    |      |      |      | B    | B    | B    | B    | B    | B    |      |      |      |      |      |      |      |      |      |      |      |
| C    |      |      |      |      |      |      |      |      |      | C    | C    | C    | C    |      |      |      |      |      |      |      |
| D    |      |      |      |      |      |      |      |      |      |      |      |      |      | D    | D    | D    | D    | D    |      |      |
| E    |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      | E    | E    |

![image-20210422173121744](https://cdn.jsdelivr.net/gh/yanzhenxing123/blogImg@master/typora202104/22/173122-167985.png)



### 短作业（进程）优先调度算法（SJF）

`Shortest Job First `

+ 短作业(进程)优先调度算法，是指对短作业或短进程优先调度的算法，它们可以分别用于作业调度和进程调度，是根据服务的时间经行选择；

+ 短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行；

+ 短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。



| 进程 | 到达时间 | 服务时间 |
| ---- | -------- | -------- |
| A    | 0        | 3        |
| B    | 2        | 6        |
| C    | 4        | 4        |
| D    | 6        | 5        |
| E    | 8        | 2        |

要注意作业/进程是否达到，达到越早、服务时间越短越先调入，针对该例题为：A-B-E-C-D
简单模拟时间轴表示其过程：

|      | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   | 16   | 17   | 18   | 19   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| A    | A    | A    | A    |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| B    |      |      |      | B    | B    | B    | B    | B    | B    |      |      |      |      |      |      |      |      |      |      |      |
| C    |      |      |      |      |      |      |      |      |      |      |      | C    | C    | C    | C    |      |      |      |      |      |
| D    |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      | D    | D    | D    | D    | D    |
| E    |      |      |      |      |      |      |      |      |      | E    | E    |      |      |      |      |      |      |      |      |      |

​				

| 进程 | 到达时间 | 服务时间 | 开始时间 | 结束时间 | 周转时间 | 带权周转时间 |
| ---- | -------- | -------- | -------- | -------- | -------- | ------------ |
| A    | 0        | 3        | 0        | 3        | 3        | 1            |
| B    | 2        | 6        | 3        | 9        | 7        | 1.17         |
| C    | 4        | 4        | 11       | 15       | 11       | 2.75         |
| D    | 6        | 5        | 15       | 20       | 14       | 2.8          |
| E    | 8        | 2        | 9        | 11       | 3        | 1.5          |





![image-20210422173113619](https://cdn.jsdelivr.net/gh/yanzhenxing123/blogImg@master/typora202104/22/173114-435391.png)



- SJF调度算法，对长作业不利；
- 更严重的是，如果有一长作业进入系统的后备队列，由于调度程序总是优先调度那些短作业，将导致长作业长期不被调度（“ **饥饿**”现象 ）。



### 优先级调度算法

+ 优先级调度算法又称优先权调度算法，该算法既可以用于作业调度，也可以用于进程调度，该算法中的优先级用于描述作业运行的紧迫程度。

+ 在作业调度中，优先级调度算法每次从后备作业队列中选择优先级最髙的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列；

+ 在进程调度中，优先级调度算法每次从就绪队列中选择优先级最高的进程，将处理机分配给它，使之投入运行。

**根据新的更高优先级进程能否抢占正在执行的进程，可将该调度算法分为**

+ 非剥夺式优先级调度算法，当某一个进程正在处理机上运行时，即使有某个更为重要或紧迫的进程进入就绪队列，仍然让正在运行的进程继续运行，直到由于其自身的原因而主动让出处理机时（任务完成或等待事件），才把处理机分配给更为重要或紧迫的进程。

+ 剥夺式优先级调度算法，当一个进程正在处理机上运行时，若有某个更为重要或紧迫的进程进入就绪队列，则立即暂停正在运行的进程，将处理机分配给更重要或紧迫的进程。

**根据进程创建后其优先级是否可以改变，可以将进程优先级分为以下两种**

+ 静态优先级，优先级是在创建进程时确定的，且在进程的整个运行期间保持不变。确定静态优先级的主要依据有进程类型、进程对资源的要求、用户要求。

+ 动态优先级，在进程运行过程中，根据进程情况的变化动态调整优先级。动态调整优先级的主要依据为进程占有CPU时间的长短、就绪进程等待CPU时间的长短。



### 高响应比优先调度算法（HRRN）

高响应比算法，是一种**动态调整**优先级的算法

因为可能造成一个低优先级作业始终得不到执行。为了解决这个问题，HRRN算法每次都计算作业的优先级，随着作业等待时间的变长，优先级不断的提高，所以能够得到更快的执行。

> 这个优先级可以描述为:
>
> **优先级 = (作业已等待时间 + 作业的服务时间) / 作业的服务时间**

从上式可以看到，作业的服务时间是固定的， 优先级随着已等待时间的提高而变大。也就是`FCFS` 和 `SJF`两种算法的中和。

![image-20210422174712468](https://cdn.jsdelivr.net/gh/yanzhenxing123/blogImg@master/typora202104/22/174712-458136.png)





### 时间片轮转调度算法（RR）

+ 时间片轮转调度算法主要适用于分时系统；

+ 在这种算法中，系统将所有就绪进程按到达时间的先后次序排成一个队列，进程调度程序总是选择就绪队列中第一个进程执行，即先来先服务的原则，但仅能运行一个时间片，如100ms。在使用完一个时间片后，即使进程并未完成其运行，它也必须释放出（被剥夺）处理机给下一个就绪的进程，而被剥夺的进程返回到就绪队列的末尾重新排队，等候再次运行。

+ 在时间片轮转调度算法中，时间片的大小对系统性能的影响很大。如果时间片足够大，以至于所有进程都能在一个时间片内执行完毕，则时间片轮转调度算法就退化为先来先服务调度算法；如果时间片很小，那么处理机将在进程间过于频繁切换，使处理机的开销增大，而真正用于运行用户进程的时间将减少，因此时间片的大小应选择适当。

+ 时间片的长短通常由以下因素确定：系统的响应时间、就绪队列中的进程数目和系统的处理能力。





###  多级反馈队列(轮转)调度算法

![image-20210422175344819](https://cdn.jsdelivr.net/gh/yanzhenxing123/blogImg@master/typora202104/22/175345-969716.png)

即:`RR`和` 优先级调度算法` 的中和。



+ 通过动态调整进程优先级和时间片大小，多级反馈队列调度算法可以兼顾多方面的系统目标。

+ 例如，为提高系统吞吐量和缩短平均周转时间而照顾短进程；为获得较好的I/O设备利用率和缩短响应时间而照顾I/O型进程；同时，也不必事先估计进程的执行时间。

**特点**

1. 提高吞吐量和缩短平均周转时间而照顾短进程；
2. 为获得较好的I/O设备利用率和缩短响应时间而照顾I/O型进程；
3. 不必事先估计进程的执行时间。



**如何工作**

1. **多个就绪队列**，第一队列优先级最高；
2. 赋予各个队列中进程执行时间片的大小不一样，优先级越高的队列中，多个进程的运行时间片越小；
3. 新进程进入内存后，按FCFS原则排队等待调度。

## 进程调度源码分析

### Linux 0.11的调度函数schedule

`kernel/sched.c`
`schedule` 的目的是找到下一个任务 `next`，切换到下一个任务。

> 找到最高的优先级

```c
/*
 * 'schedule()' is the scheduler function. This is GOOD CODE! There
 * probably won't be any reason to change this, as it should work well
 * in all circumstances (ie gives IO-bound processes good response etc).
 * The one thing you might take a look at is the signal-handler code here.
 *
 * NOTE!! Task 0 is the 'idle' task, which gets called when no other
 * tasks can run. It can not be killed, and it cannot sleep. The 'state'
 * information in task[0] is never used.
 */
/*
 * 'schedule()'是调度函数。没有任何理由对它进行修改，因为它可以在所有的
 * 环境下工作（比如能够对IO-边界处理很好的响应等）。只有一件事值得留意，那就是这里的信号
 * 处理代码。
 * 注意！！任务0 是个闲置('idle')任务，只有当没有其它任务可以运行时才调用它。它不能被杀
 * 死，也不能睡眠。任务0 中的状态信息'state'是从来不用的。
 */
void schedule (void)s
{
  int i, next, c;
  struct task_struct **p;   // 任务结构指针的指针。
  ……

  while (1)
  {
      c = -1;
      next = 0;
      i = NR_TASKS;//从后往前遍历
      p = &task[NR_TASKS];//将p设为task数组的最后一个地址
      // 这段代码也是从任务数组的最后一个任务开始循环处理，比较每个就绪
      // 状态任务的counter（任务运行时间的递减滴答计数）值，哪一个值大，运行时间还不长，next 就
      // 指向哪个的任务号。
      while (--i)
      {
        if (!*--p)
          continue;
        //Linux 0.11中，TASK_RUNNING是就绪态，counter是时间片
        if ((*p)->state == TASK_RUNNING && (*p)->counter > c)
          //判断是就绪态，并且 counter>-1，就给c和next赋值，遍历找到最大的counter
          c = (*p)->counter, next = i;
      }
      // 如果比较得出有counter 值大于0 的结果，则退出while(1)的循环，执行任务切换。
      // counter 最大的任务，优先级最高
      if (c)
        break;
      // 否则c=0，说明就绪态的时间片都用完了，根据每个任务的优先权值，更新每一个任务的counter 值。
      // counter 值的计算方式为counter = counter /2 + priority
      for (p = &LAST_TASK; p > &FIRST_TASK; --p)
        if (*p)
        //执行过的任务 比初始任务 优先级高
          (*p)->counter = ((*p)->counter >> 1) + (*p)->priority;
    }
  switch_to (next);     // 切换到任务号为next 的任务，并运行。
}
```

所以先去找所有就绪状态任务中的最大counter，大于零，则直接切过去，否则，更新所有任务的counter, 更新的值为counter = counter >> 1+ priority, 然后进入下一次的找最大counter大于零否则更新counter的过程，所以说那些没有你在就绪态的一直在更新，counter也就越大。当为就绪态时，也就可以优先的切过去。照顾了IO进程，变相照顾了前台进程。





> 时间片的切换

当`counter`减到0的时候，就进行调度，也就是进程之间的切换。

```c++
// shced.c
void shed_init(void)
{
    set_intr_gate(0x20, &timer_interrupt);
}

// 时钟中断
void _timer_interrupt: 
    ...
    call do_timer

void do_timer(...)
{
    if((--current->counter > 0))
        return;
    current-> counter = 0;//counter减到0，就schedule
    schedule();
}
```

所以`counter`有两个作用：

+ 时间片
+ 优先级



所体现的算法：

1. 优先级调度算法
2. 时间片轮转 RR 
3. SJF（后台一直在按counter进行轮转，那么短任务（服务时间短的任务会被先执行完））

