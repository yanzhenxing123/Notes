# 死锁

## 原因

所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。 因此我们举个例子来描述，如果此时有一个线程A，按照先锁a再获得锁b的的顺序获得锁，而在此同时又有另外一个线程B，按照先锁b再锁a的顺序获得锁。持有并不放开一个资源。

![image-20210426211938840](https://cdn.jsdelivr.net/gh/yanzhenxing123/blogImg@master/typora202104/26/211939-653277.png)

## 解决办法

普通pv操作进行处理生产者-消费者问题：

```c
//用文件定义 共享缓冲区
int fd = open("buffer.txt");
write(fd, 0, sizeof(int));//写in
write(fd, 0, sizeof(int));//写out

//信号量的定义和初始化
semaphore full = 0;//生产的产品的个数
semaphore empty = BUFFER_SIZE;//空闲缓冲区的个数
semaphore mutex = 1;//互斥信号量

//生产者
Producer(item)
{
    P(empty);//生产者先判断 缓存区个数 empty是否满了，empty == 0，阻塞
    P(mutex);//操作文件前，用mutex防止其他进程操作该文件
    读入in，将item写到in的位置上
    V(mutex);//使用完文件，释放文件资源
    V(full);//生产者生产产品，增加full，消费者就可以消费了
}

//消费者
Consumer()
{
    P(full);//当full == 0,缓冲区空了，阻塞
    P(mutex);
    读入out，从文件中的out位置读出到item，打印item;
    V(mutex);
    V(empty);//消费者消耗产品，增加缓冲区个数，增加empty，生产者就可以继续生产了
}
```

考虑将pv操作进行换位，先进行互斥操作，后进行同步操作。

```c
//用文件定义 共享缓冲区
int fd = open("buffer.txt");
write(fd, 0, sizeof(int));//写in
write(fd, 0, sizeof(int));//写out

//信号量的定义和初始化
semaphore full = 0;//生产的产品的个数
semaphore empty = BUFFER_SIZE;//空闲缓冲区的个数
semaphore mutex = 1;//互斥信号量

//生产者
Producer(item)
{
    P(mutex);//操作文件前，用mutex防止其他进程操作该文件
    P(empty);//生产者先判断 缓存区个数 empty是否满了，empty == 0，阻塞
    读入in，将item写到in的位置上
    V(full);//生产者生产产品，增加full，消费者就可以消费了
    V(mutex);//使用完文件，释放文件资源
}

//消费者
Consumer()
{
    P(mutex);
    P(full);//当full == 0,缓冲区空了，阻塞
    读入out，从文件中的out位置读出到item，打印item;
    V(empty);//消费者消耗产品，增加缓冲区个数，增加empty，生产者就可以继续生产了
    V(mutex);
}
```

当`empty = 0`时，执行生产者，`P(mutex)`操作获得锁，`P(empty)`，empty = -1，那么生产者将会阻塞，然后切换到消费者进程，由于拿不到锁，将不会进行消费操作。反过来，当`full = 0`时，先执行消费者，也是如此。

### 产生的条件

+ 互斥使用（Mutual exclusion）
  资源的固有特性，如道口
+ 不可抢占（No preemption）
  资源只能自愿放弃，如车开走以后
+ 请求和保持（Hold and wait）
  进程必须占有资源，再去申请
+ 循环等待（Circular wait）
  在资源分配图中存在一个环路

## 死锁处理

### 死锁预防

#### 破坏 互斥

就是在系统里取消互斥。若资源不被一个进程独占使用，那么死锁是肯定不会发生的。但一般来说在所列的四个条件中，“互斥”条件是无法破坏的。因此，在死锁预防里主要是破坏其他几个必要条件，而不去涉及破坏“互斥”条件。

> 注意：互斥条件不能被破坏，否则会造成结果的不可再现性。

#### 破坏 不可抢占

破坏“不可抢占”条件就是允许对资源实行抢夺。

+ 方法一：如果占有某些资源的一个进程进行进一步资源请求被拒绝，则该进程必须释放它最初占有的资源，如果有必要，可再次请求这些资源和另外的资源。
+ 方法二：如果一个进程请求当前被另一个进程占有的一个资源，则操作系统可以抢占另一个进程，要求它释放资源。只有在任意两个进程的优先级都不相同的条件下，方法二才能预防死锁。

#### 破坏 占有并等待条件

破坏“占有并等待”条件，就是在系统中不允许进程在已获得某种资源的情况下，申请其他资源。即要想出一个办法，阻止进程在持有资源的同时申请其他资源。

+ 方法一：创建进程时，要求它申请所需的全部资源，系统或满足其所有要求，或什么也不给它。这是所谓的 “ 一次性分配”方案。
+ 方法二：要求每个进程提出新的资源申请前，释放它所占有的资源。这样，一个进程在需要资源S时，须先把它先前占有的资源R释放掉，然后才能提出对S的申请，即使它可能很快又要用到资源R。

#### 破坏 循环等待条件

破坏“循环等待”条件的一种方法，是将系统中的所有资源统一编号，进程可在任何时刻提出资源申请，但所有申请必须按照资源的编号顺序（升序）提出。这样做就能保证系统不出现死锁。

### 死锁避免

理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。所以，在系统设计、进程调度等方面注意如何让这四个必要条件不成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。

**预防死锁和避免死锁的区别：**
预防死锁是设法至少破坏产生死锁的四个必要条件之一,严格的防止死锁的出现,而避免死锁则不那么严格的限制产生死锁的必要条件的存在,因为即使死锁的必要条件存在,也不一定发生死锁。避免死锁是在系统运行过程中注意避免死锁的最终发生。

#### 有序资源分配法

这种算法资源按某种规则系统中的所有资源统一编号（例如打印机为1、磁带机为2、磁盘为3、等等），申请时必须以上升的次序。系统要求申请进程：
　　1、对它所必须使用的而且属于同一类的所有资源，必须一次申请完；
　　2、在申请不同类资源时，必须按各类设备的编号依次申请。例如：进程PA，使用资源的顺序是R1，R2； 进程PB，使用资源的顺序是R2，R1；若采用动态分配有可能形成环路条件，造成死锁。
　　采用有序资源分配法：R1的编号为1，R2的编号为2；
　　PA：申请次序应是：R1，R2
　　PB：申请次序应是：R1，R2
　　这样就破坏了环路条件，避免了死锁的发生。



#### 银行家算法



```c
int Available[1..m]; //每种资源剩余数量
int Allocation[1..n, 1..m];  //已分配资源数量
int Need[1..n, 1..m];  //进程还需的各种资源数量
int Work[1..m];  //工作向量
bool Finifh[1..n];  //进程是否结束

Work = Available;
Finifh[1..n] = false;
while(true)
{
    for(i = 1; i <= n; i++)
    {
        // Need[i] <= Work 这个任务是可以完成的
        if(Finish[i] == false && Need[i] <= Work)
        {
            Work = Work + Allocation[i];  // Work 累加系统曾分配给 i 的资源
            Finish[i] = true;
            break;
        } else {
            goto end;
        }
    }
}

End: for(i = 1; i <=n; i++)
        if(Finish[i] == false)
            return "deadlock";
```

时间复杂度是 T(n) = O(m* n^2)，m是资源数，n是进程数
系统中的 资源和 进程都很多，执行的代价还是很大的

**银行家算法实例：**

![这里写图片描述](https://img-blog.csdn.net/20170131222317361?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamllcWlvbmcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)



应用时，首先假装分配，然后调用 银行家算法，如果给进程1分配资源，进程1执行完，其他进程都不能执行，则拒绝进程1 的资源申请.

> 避免死锁的技术

1. 加锁顺序（线程按照一定的顺序加锁）
2. 加锁时限（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁）
3. 死锁检测



### 死锁检测和恢复

**发现死锁，然后再进行处理。**

- 选择哪些进程回滚？回滚的依据是什么，是优先级，还是占有资源多少。
- 如何实现回滚？那些已经修改的文件怎么办？
  回滚容易出错，比如存款程序，用户已经往账户里打钱，信息已经写到一个文件里了，现在要回滚，这个钱已经在银行了。回滚会出错。

### 死锁忽略

鸵鸟算法

Windows 和 Linux 都 采用了 死锁忽略的方法

- 死锁忽略的处理代价最小
-  这种机器上出现死锁的概率比其他机器低
-  死锁可以用重启来解决，PC重启造成的影响小
-  死锁预防让编程变得困难



### End

+ 死锁预防 引入太多不合理因素
+ 死锁避免 每次申请都执行银行家算法，效率太低
+ 死锁检测 + 恢复 恢复很不容易，进程造成的改变很难恢复
+ 死锁忽略 死锁出现是不确定的，可以用重启来处理死锁 大多数非专门的操作系统都用 死锁忽略，如 UNIX，Linux，Windows