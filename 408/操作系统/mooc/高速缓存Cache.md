



# Cache（映射、替换、写机制）

## 引入缓存原因

对于大多数人来说Cache，是透明的、不存在的。其中一个原因是Cache是集成到CPU中，对于程序员来说是透明的。

1. CPU通用寄存器的速度与主存之间存在这太大的差异。CPU的通用寄存器的速度一般小于1ns，主存的速度一般是65ns。速度差异近百万。
2. 程序访问的空间局部性、时间局部性。在较短时间间隔内，程序产生的地址往往集中在一个很小范围内。比如：一个很大的循环程序段，在一段时间内一直在局部区域执行指令，故循环内指令的时间局部性好；一段连续地址的数据元素，按顺序遍历故程序空间局部性好。

如何将缓存和内存关联：

CPU在获取指令时，在主存中把一段数据，都搬到Cache中，也就把下一个执行的指令一起搬到Cache中了。

> 在一段时间内,CPU所执行的程序和访问的数据大部分都在某一段地址范围内，而该段范围外的地址访问很少

### 结构模块化

+ CPU访问cache或主存时，以字为单位；

+ Cache和主存交换信息时，以块为单位，一次读入一块或多块内容；每块由若干个字组成；

+ Cache的每行都设置有标记，CPU访问程序或数据时，先访问标记 。

#### 分块

主存被分成若干大小相同的块，称为主存块；Cache也被分成相同大小的块，称为Cache行（line）或槽。

### Cache基本构成

+ 存储体

  + 基本单位为字，若干个字构成一个数据块

+ 地址映射变换机制

  + 用于将主存地址变换为Cache地址，以利用CPU发送的主存地址访问Cache

+ 替换机制

  + 若要更新Cache中数据时使用的机制

+ 相联存储器

  + Cache的块表，快速指示所要访问的信息是否在Cache中

+ 独写控制

  1. 读操作

     + 经地址变换机制，变换为可能的Cache地址；

     +  查找块表，判断所要访问的信息是否在Cache中；

     +  若在，则CPU直接读取Cache获取数据；

     +  若不在，则CPU访问主存，并判断Cache是否已满；

        若Cache未满，将该数据所在块从主存中调入Cache；

        若Cache已满，使用某种替换机制，使用当前数据块替换掉Cache中的某些块。

  2. 写操作

     +  经地址变换机构，变换为可能的Cache地址；
     +  查找对应的相联存储器，判断所要访问的信息是否在Cache中；
     +  若不在，则使CPU直接写主存数据；
     +  若在，则使用某种写策略将数据写入Cache。

l命中率是指CPU要访问的信息在cache中的比率；

## 主存块和Cache之间的映射

### 概念

cache相对于程序员是透明的。当给出一个主存地址时，先去cache中去找这个地址，怎么找，就是一种映射。在cache中未找到时，也就是未命中，需要在主存中找，然后需要将要访问的字所在主存中的块调入到cache中，也就是**s**。



命中率：指CPU要访问的信息在cache中的比率

<img src="https://cdn.jsdelivr.net/gh/yanzhenxing123/blogImg@master/typora202105/02/005604-702220.png" alt="image-20210502005603717" style="zoom:50%;" />

影响命中率的主要因素:

+ Cache容量
  + 过小：局部信息装不完，命中率低
  + 过大：对提高效率不明显，并且成本高
+ Cache中块的大小
  + 一般用一个主存周期所能调出的单元数（字或字节）作为一个块大小。

### 全相联映射

可以将一个主存块存储到任意一个Cache行。

发现V为0（无效），就把主存块放到对应的槽。并把V设置为1。也就是说，主存块放到Cache是无序的，没有规则的。看见有空位就占。所以，CPU在找对应的内存地址时，**都要遍历**。



优点：命中率较高，Cache的存储空间利用率高
缺点：线路复杂，成本高，速度低

<img src="https://cdn.jsdelivr.net/gh/yanzhenxing123/blogImg@master/typora202105/01/235625-596968.png" alt="image-20210501235625510" style="zoom: 67%;" />





### 直接映射（模映射）

将一个主存块存储到唯一的一个Cache行

多对一的映射关系，但一个主存块只能拷贝到cache的一个特定行位置上去。
cache的行号i和主存的块号j有如下函数关系：i=j mod m（m为cache中的总行数）
优点：硬件简单，容易实现
缺点：命中率低， Cache的存储空间利用率低。



<img src="https://cdn.jsdelivr.net/gh/yanzhenxing123/blogImg@master/typora202105/01/235450-899368.png" alt="image-20210501235450328" style="zoom: 67%;" />

### 组相联映射

将cache分成u组，每组v行，主存块存放到哪个组是固定的，至于存到该组哪一行是灵活的，即有如下函数关系：cache总行数m＝u×v    组号q＝j mod u

组间采用直接映射，组内为全相联
优点：硬件较简单，速度较快，命中率较高

<img src="https://cdn.jsdelivr.net/gh/yanzhenxing123/blogImg@master/typora202105/01/235804-286582.png" alt="image-20210501235803200" style="zoom:67%;" />

## Cache的替换策略

+ 先进先出(FIFO)

+ LRU（Least Recently Used） **最近最少用 **命中行不加，其余行加1。替换时看谁计数大，替换谁。

+ 最不常用（LFU）
+ 随机替换算法（Random）

## Cache写机制

### 缓存命中写入 write-hit

1. **直写**（Write Through）：同时写Cache和主存单元，但是主存写的太慢。数据多时，容易造成CPU堵塞。解决办法：**post write** 使用写缓冲（Write Buffer）。CPU不再等主存写 完数据。直接把数据丢到Buffer中。

   ![image-20210502002321784](https://cdn.jsdelivr.net/gh/yanzhenxing123/blogImg@master/typora202105/02/002322-532642.png)

2. **回写**（write back）：在数据更新时只写入缓存Cache，而不是立即写入内存。只在数据**被替换出缓存**时，被修改的缓存数据才会被写到后端存储。此模式的优点是数据写入速度快，因为不需要写存储；缺点是一旦更新后的数据未被写入存储时出现系统掉电的情况，数据将无法找回。对一cache行的多次写命中都在cache中快速完成修改，只是需被替换时才写回速度较慢的主存，减少了访问主的次数从而提高了效率。为支持这种策略，每个cache行必须配置一个修改位，以反映此行是否被CPU修改过。

   

   

### 写缺失的处理方式 Write-misses

1. **写分配**（Write Allocate）：先将写入位置的数据读入缓存Cache，然后采用write-hit（缓存命中写入）操作。这种方式下，写缺失操作与读缺失操作类似。
2. **非写分配**（No-Write Allocate）：并不将写入位置的数据读入缓存Cache，而是直接将数据写入存储。这种方式下，**只有读操作会被缓存。**