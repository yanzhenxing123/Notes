# 限流

---
tags: [并发, golang]

categories: 项目 

---



categories: test
---

## 漏桶算法

以恒定的速率进行传输数据，强行限制数据的传输速率。

<img src="https://i.loli.net/2021/07/21/QwjXlBdhJpqxG1y.png" alt="image-20210721155407638" style="zoom:50%;" />

## 令牌桶算法

从桶里面取令牌，如果没有令牌了则拒绝请求

<img src="https://i.loli.net/2021/07/21/l3fCMy7xjbFvURY.png" alt="image-20210721155535172" style="zoom:50%;" />

## 使用场景

+ 漏桶算法可以保护第三方的系统，因为当我们调用第三方系统时，即使我们有能力处理这些并发请求，但是我们不能保证第三方的系统也有能力处理这些并发，但是我们没有办法去更改别人的系统，所以可以使用此算法**保护别人的系统**
+ 令牌桶算法可以有效的提高数据的传输能力，可以保护我们自己的系统。





## 代码示例

```go
package main

import (
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/juju/ratelimit"
)

func RateLimitMiddleware(fillInterval time.Duration, cap, quantum int64) gin.HandlerFunc {
	bucket := ratelimit.NewBucketWithQuantum(fillInterval, cap, quantum)
	return func(c *gin.Context) {
		// 如果桶里边的数据少于1，那么拒绝请求
		if bucket.TakeAvailable(1) < 1 {
			c.String(http.StatusForbidden, "rate limit...")
			c.Abort()
			return
		}
		c.Next()
	}
}

/*
1. 令牌桶初始化后里面就有 100 个令牌
2. 每秒钟会产生 100 个令牌, 保证每秒最多有 100 个请求通过限流器, 也就是说 QPS 的上限是 100
3. 流量过大时能够启动限流, 在限流过程中, 仍然能让部分流量通过
*/
func main() {
	r := gin.Default()
	gin.ForceConsoleColor()
	r.Use(RateLimitMiddleware(time.Second, 100, 100))
	r.GET("/", func(c *gin.Context) {
		c.String(http.StatusOK, "golang ~")
	})
	err := r.Run(":8080")
	if err != nil {
		return
	}
}

```



