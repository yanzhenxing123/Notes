## 事务

事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位。

读取数据问题的情况：

+ 脏读：读取未提交的数据 
  + 解决: 读提交
+ 不可重复读：读取的是行级别的数据
  + 解决: 对行加锁
+ 幻读：前后多次读取，读取到的总量不一致，读取的是表级别的数据
  + 解决: 对表加锁



1. 事务的特性（acid）
   + 原子性（atomicity）：要么执行要么不执行
   + 一致性（consistency）：eg：执行转账加起来是多少还是多少
   + 隔离性（isolation）：一个事务未提交时对其他事务的可见状态。
   + 持久性（durability）: 一个事务一旦执行，那么对数据库的影响就是永久性的。

2. 事务的隔离级别

   + read uncommitted 读未提交

   + read committed 读提交

   + repeatable read 重复读（mysql 默认）

   + serializable 序列化（串行化）

   

## innodb

![](https://i.loli.net/2021/11/28/Ih82BMU1HG4lXAi.png)

1. 四大特性
   + 插入缓冲
   + 二次写
   + 自适应哈希索引
   + 预读
2. 存储引擎的选择
   + 默认innodb
   + Myisam以读写插入为主的应用程序，eg: 博客、新闻门户网站
   + innodb：更新删除频率也高、保证数据的完整性，支持事务和外键，并发量较高
3. 二者之间的区别
   + innodb聚簇索引，myisam非聚簇索引
   + innodb的主键索引叶子结点存储着行数据，
   + MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。
   + InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效
   + 索粒度不同：myisam使用表锁，innodb支持表锁和行锁，默认是行锁





## 索引

1. 索引使用的场景

   + where
   + order by
   + join on

2. 索引的类型

   + 主键索引
   + 唯一索引 允许为null值
   + 普通索引 允许为null值
   + 全文索引

3. 索引的数据结构

   + hash
   + b+树

4. 索引创建的原则

   + 最左前缀匹配原则（**组合索引**非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配）
   + 频繁查询的数据
   + 更新频繁的字段不作为索引
   + 尽量扩展索引，避免建立新的索引

5. 创建索引的三种方式

   1. 创建表的时候建立索引
   2. 使用alter table 增加索引 `alter table student add index index_name(column_name)`
   3. 使用create index index_name on column_name

6. 百万级数据如何删除一条数据

   + 删除索引
   + 删除无用的数据
   + 重建索引

7. 前缀索引

   Index(filed(10)) 使用字段值的前10个字符建立索引，默认是使用字段的全部内容建立索引

   前提：前缀的表示度高，比如：密码、通讯录、姓氏

8. b树和b+树

   ![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC85LzIxLzE2NWZiNjgyZTc1OWNmMTI?x-oss-process=image/format,png)

   b树的好处：

   ​	内部节点存储k, v键值对，将热点数据放到靠近根节点可以大大提高查询效率

   b+树的好处：

   ​	+ 一次读取，可以在内存页中获取更多的键，有利于更快的缩小范围查找

   ​	+ 遍历全部的数据，b+树找到最小的节点，然后将数据全部load进内存即可。

9. hash索引和b+树索引

   + hash需要回表查询，b+树可能需要回表查询
   + 范围查询支持与否
   + hash不支持索引上进行排序

10. 数据库为什么使用b+树而不是b树

    + b树只适合随机索引，而b+树适合顺序索引和随机索引
    + b+树的查询效率更加稳定
    + b+树顺序遍历和范围遍历时磁盘io更少

11. 聚簇索引和非聚簇索引

    + 聚簇：数据和索引在一起
    + 非聚簇：数据和索引不在一起, 叶子结点存储(key + 主键id)
    + 用非聚簇索引查找时不一定要进行回表，因为select key, id from table where key  = "xxx" 那么就不用进行回表

## 锁

1. x锁和s锁 （排它锁和共享锁）

   一个事务对对象加了s锁，其他事务可以加s锁，但不能加x锁，所以s锁也就是读锁

   一个事务对对象加了x锁，其他事务不可以加s锁也不可以加x锁，所以s锁也就是写锁

   

   

2. 隔离级别和锁

   + read uncommitted : 不加锁

   + read committed ：加行级别共享锁，并且一条语句执行完毕之后释放锁

   + repeatable read: 加行级别共享锁，但是一个事务执行完之后才可以释放锁

   + serializable：锁定整个范围的键

     

3. 悲观锁和乐观锁

   **悲观锁**（适用于**多写**的场景）

   + 在悲观锁的情况下，为了保证事务的隔离性，就需要一致性锁定读。读取数据时给加锁，其它事务无法修改这些数据。修改删除数据时也要加锁，其它事务无法读取这些数据。
   + 依靠数据库的锁机制实现

   **乐观锁** (适用于**多读**的场景)

   假设不会发生并发冲突，在修改数据的时候把事务锁起来，通过version的方式来进行锁定。使用cas算法或者版本号进行实现

4. 死锁

   + 两个及两个以上的事务互相请求对方的资源，从而导致恶性循环的现象
   + 解决方法：
     + 按照顺序进行请求资源
     + 锁粒度的修改
     + 同一个事务，尽可能做到一次锁定所需要的所有资源

## 视图



## 面试题

1. sql的生命周期

   + 应用服务器和数据库服务器建立连接
   + 数据库进程拿到请求sql
   + 解析并生成执行计划，执行
   + 读取到内存并进行逻辑处理
   + 通过步骤一的连接发送结果到客户端
   + 关闭连接 释放资源

   
