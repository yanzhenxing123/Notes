## TCP和UDP的区别

### TCP

+ 面向连接的服务：这条连接是全双工的
+ 提供可靠传输：传送的数组无差错、不丢失、不重复、按序到达
+ 有拥塞控制
  + 当网络出现拥塞时，此机制会抑制发送进程（客户端或服务器）
  + 试图限制每一个TCP连接
+ 面向字节流
+ 每一条TCP连接只能是点到点
+ 首部开销20个字节
+ 只支持单播

#### 关于TCP的安全性

tcp和udp在发送时是没有进行加密的，所以具有安全隐患。为了解决这一问题，ssl就产生了。

SSL不是TCP和UDP在相同层次上产生的第三种协议，而是对TCP的一种增强。中文名字伟“安全套接字层”。

#### 滑动窗口

以字节为单位，发送方根据接收方的窗口大小来确定自己的窗口大小。接收方会把没有收到的最小序列作为ACK序列，表明自己想要这个。发送方和接收方都有自己的放松窗口和接收窗口。

+ 可靠性
+ 流量控制

#### 拥塞控制的实现

![image-20211124095331728](https://i.loli.net/2021/11/24/RyTGQtSbOPhqmwv.png)

1. 慢启动

   + 启动的时候把拥塞窗口的值设置成最大报文段MSS的数值，接收到一个报文就增加一个MMS，呈指数进行增长

2. 拥塞避免

   + 当达到慢开始门限的时候，慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2）
   + 然后把cwnd（拥塞窗口）设置为1

3. 快重传

   + 接收方收到失序的报文段时，不等待自己发送报文捎带确认，立即发送重复确认，目的是让发送方尽早知道发送报文没有到达接收方。

4. 快恢复

   ![](https://github.com/wolverinn/Waking-Up/raw/master/_v_images/20191129161026032_32431.png)

   + 当发送方连续收到三个重复确认时，就把慢开始门限减半，然后执行拥塞避免算法。不执行慢开始算法的原因：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方认为现在网络可能没有出现拥塞。
   + 有的算法会将cwnd再增大一些，等于ssthresh + 3*MSS ，因为是哪个重复确认发送了没有到达数据包后面的三个数据包。

#### 三次握手和四次挥手

![image-20211010130911124](https://i.loli.net/2021/10/10/sMh3xobCHrTgLqI.png)

![image-20211010130954537](https://i.loli.net/2021/10/10/RFJ3WmTdCQrplUn.png)





#### 面试题

1. 为什么是三次握手？

​	三次握手保证了双方的发送能力和接收能力

 + 三次握手可以阻断历史连接的初始化（主要原因）
   + 滞留的第一个连接请求报文段到达server，如果是两次握手，那么服务端发送确认连接后，就处于建立连接的状态，而三次握手的话，client需要发送RST报文给服务端，表示终止这次连接。
   + 三次握手可以在第三次报文中指定是是否是历史连接
 + 可以初始双方的序列号（两次握手只能保证一方的序列号被对方得知）
   + 接收方可以去除重复的数据
   + 接收方可以根据数据包的序列号按序接收
   + 可以知道发送出去的数据包中哪些是被收到的

 + 可以避免资源浪费
   + 两次连接server发送后就建立了连接，并没有考虑是否是历史请求数据包或者自己的确认数据包没有发送出去

2. 服务器出现大量time_wait

 + time_wait状态是服务器确认关闭连接，本地接收后，发送ack连接后，进入time_wait状态，默认时间为2MSL时间（linux中2msl默认为60s）

 + 大量的短连接存在( http1.0使用短连接)

 + HTTP请求头里connection值被设置为close

   + 如果HTTP请求中，connection的值被设置成close，那就相当于告诉server：server执行完HTTP请求后去主动关闭连接

   **解决方法**

   + 客户端
     + 短连接使用长连接
     + client -> nginx -> server之间的连接都设置长连接
   + 服务器层面
     + 允许将TIME_WAIT状态的socket重新用于新的TCP连接
     + 快速回收TIME_WAIT的socket
     + 将MSL的值缩减
       + 但是这样做会导致延迟报文无法清除以及主动关闭连接一端不能收到重传来的FIN请求，也会影响很多基于TCP的应用的连接复用和调优



3. 如何保证可靠传输

+ 校验和：发送方和接收方都会计算，如果不一致那么传输有误
+ 确认应答和序列号：发送方：seq， 接收方返回ack
+ 超时重传
+ 连接管理：超时重传的过程
+ 流量控制(滑动窗口): TCP协议报头包含16位的窗口大小，接收方会在返回ACK时同时把自己的即时窗口填入，发送方就根据报文中窗口的大小控制发送速度
+ 拥塞控制(拥塞窗口) 

4. 浏览器输入url经历的过程

+ dns解析域名获得ip地址，ip地址根据子网掩码判断ip是否和自己在同一个局域网内，构造应用层http报文，
+ 传输层添加TCP/UDP头部，TCP三次握手建立连接
+ client发送请求的资源
+ 服务器根据请求路径找到响应的资源，并返回
+ 数据经过路由器和交换机之间进行转发，最终到达目的地址。
+ 四次挥手断开连接

### UDP

+ 无连接：发送数据之前不需要建立连接
+ 尽最大努力交付，不可靠传输
+ 面向报文
+ 支持一对一，一对多，多对一，多对多
+ 首部开销比较小
+ UDP要比TCP要快
+ 支持单播、多播、广播





## HTTP

+ 基于tcp的可靠通信
+ 基于C/S架构
+ 无状态：对事务的处理没有记忆能力。
+ 无连接：限制每次连接只处理一个请求。



http1.0(短连接) -> http1.1(长连接) -> http2.0(多路复用)

1. Get和post之间的区别

   + post比get更安全
   + post和get本质上是一致的，http都是以明文的方式进行数据之间的传输，https更有利于数据的安全
   + get在浏览器上进行回退是无害的，但是post会重新提交表单。
   + get是一次发送数据，post分两次：第一次请求把header发送出去，服务器响应continue，第二次将body中的data发送出去，但是并不是所有的浏览器都是这样，Firefox就不是。

2. https的工作原理

   ![](https://pic1.zhimg.com/v2-6c4f78d2363206e1a3760a222374f348)d

3. 负载均衡实现的方式

4. + DNS轮询：将不同的ip地址绑定到同一个域名上，访问时，根据轮询的结果找到响应的主机
   + CDN(内容分发网络)：建立多个缓存节点，通过发布机制将内容同步到大量的缓存节点，通过DNS服务器进行扩展，找到离用户最近的缓存节点。
   + ip负载均衡：工作在第四层，通过修改ip和端口号，通过内部网络将数据传输到修改ip和port后的机器上，数据返回时会将ip重新修改过来，比起工作在应用层（第七层）性能要高出非常多
     + **其中LVS、HAProxy可以工作在4-7层， nginx工作在第七层**
   + web负载均衡
     + http重定向（php下载时，会重定向不同国家的服务器）
     + nginx，反向代理（将认证信息放到一个节点或者redis缓存中，避免访问一个节点而查不到session数据）



4. 说说BIO/NIO/AIO的区别

   阻塞和非阻塞：发起io请求

   同步和异步：io的读写操作

   + BIO(同步阻塞io)：**一个连接对应一个线程**

   + NIO(同步非阻塞io)：reactor模式，**一个请求对应一个线程**

     ![](https://pic3.zhimg.com/v2-6ebe35e193809e4b888cb95b56b0d8f2)

   + AIO(异步非阻塞io)：完全由操作系统完成请求的处理，**一个有效请求一个线程**

5. 对Reactor模式的理解

   + reactor：负责对io事件的响应，调用handler进行操作
   + handler：负责io事件的处理

   单线程reactor模式

   单reactor多线程模式

   多reactor多线程模式



## RIP(距离矢量路由协议)

每个路由器都维护一张表，记录该路由器到其它网络的”跳数“，路由器到与其直接连接的网络的跳数是1，每多经过一个路由器跳数就加1；更新该表时和相邻路由器交换路由信息；路由器允许一个路径最多包含15个路由器，如果跳数为16，则不可达。交付数据报时优先选取距离最短的路径。

## ARP协议

每一个路由器都存储一个ARP高速缓存表，里面有**所在的局域网**上的各主机和路由器的 IP 地址到硬件地址的映射表。

1. 同一个局域网下进行通信

源主机发送数据时，检测是否含有目的地址的mac地址，如果没有，就在所在的局域网发送一个ARP广播包，找到目的主机相同的ip地址，并返回mac地址，源主机将原地址和目标地址都放进去，然后通过mac地址发送过去

+ 局域网通信使用的mac地址进行通信 
+ arp协议用来解析目的主机的mac地址
+ arp只在同一个广播域生效
+ acp攻击是伪造arp应答

2. 两个不同网络之间进行通信

+ 源主机找到网管的mac地址，将目标mac地址修改为网关的mac地址
+ 网关使用arp协议找到下一跳路由器
+ 网关将目标mac地址修改为下一条路由器的mac地址，将源mac地址修改为自己的mac地址，源ip地址和目标mac地址不改变



